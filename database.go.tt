package main

import (
	"context"
	"sync"

	"github.com/sirupsen/logrus"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

//var client *mongo.Client
//var ctx context.Context

//func close(client *mongo.Client, ctx context.Context, cancel context.CancelFunc) {

//  defer cancel()

//  defer func() {

//    if err := client.Disconnect(ctx); err != nil {
//      panic(err)
//    }
//  }()
//}

//func connect(uri string) (*mongo.Client, context.Context, context.CancelFunc, error) {

//  ctx, cancel := context.WithTimeout(context.Background(),
//    30*time.Second)

//  client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
//  return client, ctx, cancel, err
//}

//func ping(client *mongo.Client, ctx context.Context) error {

//  if err := client.Ping(ctx, readpref.Primary()); err != nil {
//    return err
//  }
//  fmt.Println("connected successfully")
//  return nil
//}

func insertOne(client *mongo.Client, ctx context.Context, dataBase, _collection string, doc interface{}) (*mongo.InsertOneResult, error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err := collection.InsertOne(ctx, doc)
	return result, err
}

func insertMany(client *mongo.Client, ctx context.Context, dataBase, _collection string, docs []interface{}) (*mongo.InsertManyResult, error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err := collection.InsertMany(ctx, docs)
	return result, err
}

func query(client *mongo.Client, ctx context.Context, dataBase, _collection string, query, field interface{}) (result *mongo.Cursor, err error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err = collection.Find(ctx, query, options.Find().SetProjection(field))
	return
}

func UpdateOne(client *mongo.Client, ctx context.Context, dataBase, _collection string, filter, update interface{}) (result *mongo.UpdateResult, err error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err = collection.UpdateOne(ctx, filter, update)
	return
}

func UpdateMany(client *mongo.Client, ctx context.Context, dataBase, _collection string, filter, update interface{}) (result *mongo.UpdateResult, err error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err = collection.UpdateMany(ctx, filter, update)
	return
}

func deleteOne(client *mongo.Client, ctx context.Context, dataBase, _collection string, query interface{}) (result *mongo.DeleteResult, err error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err = collection.DeleteOne(ctx, query)
	return
}

func deleteMany(client *mongo.Client, ctx context.Context, dataBase, _collection string, query interface{}) (result *mongo.DeleteResult, err error) {
	collection := client.Database(dataBase).Collection(_collection)
	result, err = collection.DeleteMany(ctx, query)
	return
}

type MongoDatastore struct {
	db      *mongo.Database
	Session *mongo.Client
	logger  *logrus.Logger
}

func NewDatastore(config Config, logger *logrus.Logger) *MongoDatastore {

	var mongoDataStore *MongoDatastore
	db, session := connect(config, logger)
	if db != nil && session != nil {

		// log statements here as well

		mongoDataStore = new(MongoDatastore)
		mongoDataStore.db = db
		mongoDataStore.logger = logger
		mongoDataStore.Session = session
		return mongoDataStore
	}

	logger.Fatalf("Failed to connect to database: %v", config.Database.Name)

	return nil
}

func connect(generalConfig Config, logger *logrus.Logger) (a *mongo.Database, b *mongo.Client) {
	var connectOnce sync.Once
	var db *mongo.Database
	var session *mongo.Client
	connectOnce.Do(func() {
		db, session = connectToMongo(generalConfig, logger)
	})

	return db, session
}

func connectToMongo(generalConfig Config, logger *logrus.Logger) (a *mongo.Database, b *mongo.Client) {

	var err error
	session, err := mongo.NewClient(generalConfig.Database.Host)
	if err != nil {
		logger.Fatal(err)
	}
	session.Connect(context.TODO())
	if err != nil {
		logger.Fatal(err)
	}

	var DB = session.Database(generalConfig.Database.Name)
	logger.Info(CONNECTED, generalConfig.Database.Name)

	return DB, session
}
